// use regex::Regex;

// #[aoc_generator(dayX)]
// pub fn input_generator(input: &str) -> Vec<i32> {
//     // Numbers
//     input
//         .lines()
//         .map(|input| input.parse::<i32>().unwrap())
//         .collect()

//     // Regex
//     // let re = Regex::new(r"(?P<x>.*)x(?P<y>.*)x(?P<z>.*)").unwrap();
//     // input
//     //     .lines()
//     //     .map(|dimension| {
//     //         let data = re.captures(dimension).unwrap();
//     //         vec![
//     //             data["x"].parse::<i32>().unwrap(),
//     //             data["y"].parse::<i32>().unwrap(),
//     //             data["z"].parse::<i32>().unwrap(),
//     //         ]
//     //     })
//     //     .collect()
// }

// #[aoc(dayX, part1)]
// pub fn solve_part1(input: &[i32]) -> i32 {
//     3
// }

// #[aoc(dayX, part2)]
// pub fn solve_part2(input: &[i32]) -> i32 {
//     3
// }



// // #[cfg(test)]
// // mod tests {
// //     use super::solve_part1 as part1;
// //     use super::solve_part2 as part2;

// //     #[test]
// //     fn sample1() {
// //         assert_eq!(
// //             part1(
// //                 r#"
// // 1
// // 2
// // 3
// //             "#
// //             ),
// //             6
// //         );
// //     }
// // }
